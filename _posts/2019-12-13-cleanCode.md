---
layout: default
title: cleanCode
description: cleanCode
tags: java
---
# cleancode
	clean code，顾名思义就是整洁的代码，或者说清晰、漂亮的代码，相信大多数程序员都希望自己能写出这样的代码。很多同行在编写代码的时候往往只关注一些宏观上的主题：架构，设计模式，数据结构等等，却忽视了一些更细节上的点：比如变量如何命名与使用，控制流的设计，以及注释的写法等等。以上这些细节上的东西可以用代码的可读性来概括。不同于宏观上的架构，设计模式等需要好几个类，好几个模块才能看出来：代码的可读性是能够立刻从微观上的，一个变量的命名，函数的逻辑划分，注释的信息质量里面看出来的。宏观层面上的东西固然重要，但是代码的可读性也属于评价代码质量的一个无法让人忽视的指标：它影响了阅读代码的成本（毕竟代码是给人看的），甚至会影响代码出错的概率！代码是给人看的，顺便给机器执行。

**可读性基本定理：代码的写法应当使别人理解它所需要的时间最小化。**

![](https://www.showdoc.cc/server/api/common/visitfile/sign/918f55bfa8bfeed11556e6a65b640dca?showdoc=.jpg)
### 如何提高代码可读性
或许已经有很多同行也正在努力提高自己代码的可读性。然而这里有一个很典型的错觉：越少的代码越容易让人理解。
但是事实上，并不是代码越精简就越容易让人理解。相对于追求最小化代码行数，一个更好的提高可读性方法是最小化人们理解代码所需要的时间。
《编写可读代码的艺术》从浅入深，在三个层次告诉了我们如何让代码易于理解：

-  表层上的改进：在命名方法（变量名，方法名），变量声明，代码格式，注释等方面的改进。
-  控制流和逻辑的改进：在控制流，逻辑表达式上让代码变得更容易理解。
-  结构上的改进：善于抽取逻辑，借助自然语言的描述来改善代码。

# 表层的改进
## 如何命名
关于如何命名，作者提出了一个关键思想：

	关键思想：把尽可能多的信息装入名字中。（见名知意）
这里的多指的是有价值的多。那么如何做到有价值呢？作者介绍了以下几个建议：

	- 选择专业的词汇，避免泛泛的名字
	- 给名字附带更多信息
	- 决定名字最适合的长度
	- 名字不能引起歧义
### 选择专业的词汇，避免泛泛的名字

举个书中的例子：
有一个比较常见的反例：`returnValue`和`retval`。这两者都是“返回值”的意思，他们被滥用在各个有返回值的函数里面。其实这两个单词除了携带他们本来的意思返回值以外并不具备任何其他的信息，是典型的泛泛的名字。比如:

```
Product
ProductInfo
ProductData
```

当一个项目中出现这三个类，怎么从名字区分他们的差别。

那么如何选择一个专业的词汇呢？答案是在非常贴近你自己的意图的基础上，选择一个富有表现力的词汇。
举几个例子：

- 相对于make，选择create,generate,build等词汇会更有表现力，更加专业。
- 相对于find，选择search,extract,recover等词汇会更有表现力，更加专业。
- 相对于retval，选择一个能充分描述这个返回值的性质的名字，例如：*


但是，有些情况下，泛泛的名字也是有意义的，例如一个交换变量的情景：

```
if (right < left){
    tmp = right;
    right = left;
    left = tmp;
}
```
像上面这种tmp只是作为一个临时存储的情况下，tmp表达的意思就比较贴切了。因此，像tmp这个名字，只适用于短期存在而且特性为临时性的变量。
### 给名字附带更多信息
除了选择一个专业，贴切意图的词汇，我们也可以通过添加一些前后缀来给这个词附带更多的信息。这里所指的更多的信息有三种：

- 变量的单位
- 变量的属性
- 变量的格式
#### 为变量添加单位
有些变量是有单位的，在变量名的后面添加其单位可以让这个变量名携带更多信息：

- 一个表达时间间隔的变量，它的单位是秒：相对于duraction，ducation_secs携带了更多的信息
- 一个表达内存大小的变量，它的单位是mb：相对于size，cache_mb携带了更多的信息。
#### 为变量添加重要属性
有些变量是具有一些非常重要的属性，其重要程度是不允许使用者忽略的。例如：

- 一个UTF-8格式的html字节，相对于html，html_utf8更加清楚地描述了这个变量的格式。
- 一个纯文本，需要加密的密码字符串：相对于password，plaintext_password更清楚地描述了这个变量的特点。
#### 为变量选择适当的格式
对于命名，有些既定的格式需要注意：

- 方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式。
- 类名使用 UpperCamelCase 风格，必须遵从驼峰形式，但以下情形例外：DO / BO / DTO / VO / AO
- 常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。
- 抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名以它要测试的类的名称开始，以 Test 结尾。
- 中括号是数组类型的一部分，数组定义如下：String[] args;
- POJO 类中布尔类型的变量，都不要加 is，否则部分框架解析会引起序列化错误。
- 如果模块、接口、类、方法使用了设计模式，在命名时体现出具体模式。
### 决定名字最适合的长度

名字越长越难记住，名字越短所持有的信息就越少，如何决定名字的长度呢？这里有几个原则：

- 如果变量的作用域很小，可以取很短的名字
- 不能使用大家不熟悉的缩写
- 丢掉不必要的单元

#### 如果变量的作用域很小，可以取很短的名字
如果一个变量作用域很小：则可以给它取一个很短的名字也无妨。

看下面这个例子：
```
if(debug){
    map <string,int>m;
    LookUpNamesNumbers(m);
    Print(m);
}
```
在这里，变量的类型和使用范围一眼可见，读者可以了解这段代码的所有信息，所以即使是取m这个非常简短的名字，也不影响读者来理解作者的意图。

相反的，如果m是一个全局变量，当你看到下面这段代码就会很头疼，因为你不知道它的类型并不明确:
```
LookUpNamesNumbers(m);
Print(m);
```
#### 不能使用大家不熟悉的缩写
有些缩写是大家熟知的：

`doc` 可以代替`document`
`str` 可以代替`string`
但是如果你想用`BEManager`来代替`BackEndManager`就比较不合适了。因为不了解的人几乎是无法猜到这个名称的意义的。
所以类似这种情况不能偷懒，该是什么就是什么，否则会起到相反的效果。因为它看起来非常陌生，跟我们熟知的一些缩写规则相去甚远。* 

### 名字不能引起歧义
有些名字会引起歧义，例如：

- `clip`()：类似的，到底是在原来的基础上截掉某一段还是截掉后剩余的那一段呢？
- `booelean readPassword = true`:是表达需要读取密码，还是已经读了密码呢？所以最好使用`needPassword`或者`isAuthenticated`来代替比较好。通常来说，给布尔值的变量加上`is`,`has`,`can`,`should`这样的词可以使布尔值表达的意思更加明确
这一节讲了很多关于如何起好一个变量名的方法。其实有一个很简单的原则来判断这个变量名起的是否是好的：那就是：团队的新成员是否能迅速理解这个变量名的含义。如果是，那么这个命名就是成功的，否则就不要偷懒了，起个好名字，对谁都好。其实如果你养成习惯多花几秒钟想出个好名字，你会发现你的“命名能力”会很快提升。

##### 阿里巴巴命名规约 
1. 【强制】代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。
反例：`_name / __name / $Object / name_ / name$ / Object$`
2. 【强制】代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。
说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式
也要避免采用。
正例：`alibaba / taobao / youku / hangzhou` 等国际通用的名称，可视同英文。
反例：`DaZhePromotion [打折] / getPingfenByName() [评分] / int 某变量 = 3`
3. 【强制】类名使用 UpperCamelCase 风格，必须遵从驼峰形式，但以下情形例外：`DO / BO / DTO / VO / AO`
正例：`MarcoPolo / UserDO / XmlService / TcpUdpDeal / TaPromotion`
反例：`macroPolo / UserDo / XMLService / TCPUDPDeal / TAPromotion`
4. 【强制】方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从
驼峰形式。
正例： `localValue / getHttpMessage() / inputUserId`
5. 【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。
正例：`MAX_STOCK_COUNT`
反例：`MAX_COUNT`
6. 【强制】抽象类命名使用 `Abstract` 或 `Base` 开头；异常类命名使用` Exception` 结尾；测试类
命名以它要测试的类的名称开始，以 `Test`结尾。
7. 【强制】中括号是数组类型的一部分，数组定义如下：`String[] args;`
反例：使用 `String args[]的方式来定义。
8. 【强制】POJO 类中布尔类型的变量，都不要加 is，否则部分框架解析会引起序列化错误。
反例：定义为基本数据类型 Boolean isDeleted；的属性，它的方法也是 isDeleted()，RPC
框架在反向解析的时候，“以为”对应的属性名称是 deleted，导致属性获取不到，进而抛出异
常。
9. 【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用
单数形式，但是类名如果有复数含义，类名可以使用复数形式。
正例： 应用工具类包名为` com.alibaba.open.util`、类名为 `MessageUtils`（此规则参考spring 的框架结构）
10. 【强制】杜绝完全不规范的缩写，避免望文不知义。
反例：`AbstractClass`“缩写”命名成` AbsClass`；`condition`“缩写”命名成 `condi`，此类随意缩写严重降低了代码的可阅读性。
11. 【推荐】为了达到代码自解释的目标，任何自定义编程元素在命名时，使用尽量完整的单词
组合来表达其意。
正例：从远程仓库拉取代码的类命名为 `PullCodeFromRemoteRepository`。
反例：变量 `int a;` 的随意命名方式。
12. 【推荐】如果模块、接口、类、方法使用了设计模式，在命名时体现出具体模式。
说明：将设计模式体现在名字中，有利于阅读者快速理解架构设计理念。
正例：
```
public class OrderFactory;
public class LoginProxy;
public class ResourceObserver;
```
13. 【推荐】接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁
    性，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是
    与接口方法相关，并且是整个应用的基础常量。
    正例：接口方法签名：`void f();`
    接口基础常量表示：`String COMPANY = "alibaba";`
    反例：接口方法定义：`public abstract void f();`
    说明：JDK8 中接口允许有默认实现，那么这个 default 方法，是对所有实现类都有价值的默
    认实现。

14. 接口和实现类的命名有两套规则：
    1）【强制】对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口，内部
    的实现类用 Impl 的后缀与接口区别。
    正例：`CacheServiceImpl` 实现 `CacheService` 接口。
    2）【推荐】如果是形容能力的接口名称，取对应的形容词做接口名（通常是–able 的形式）。
    正例：`AbstractTranslator` 实现` Translatable`。

15. 【参考】枚举类名建议带上 `Enum` 后缀，枚举成员名称需要全大写，单词间用下划线隔开。
    说明：枚举其实就是特殊的常量类，且构造方法被默认强制是私有。
    正例：枚举名字为 `ProcessStatusEnum` 的成员名称：`SUCCESS / UNKOWN_REASON`。

16. 【参考】各层命名规约：
    A) Service/DAO 层方法命名规约
    1） 获取单个对象的方法用` get` 做前缀。
    2） 获取多个对象的方法用 `list`做前缀。
    3） 获取统计值的方法用 `count` 做前缀。
    4） 插入的方法用 `save/insert `做前缀。
    5） 删除的方法用 `remove/delete` 做前缀。
    6） 修改的方法用 `update` 做前缀。
    B) 领域模型命名规约
    1） 数据对象：xxxDO，xxx 即为数据表名。
    2） 数据传输对象：xxxDTO，xxx 为业务领域相关的名称。
    3） 展示对象：xxxVO，xxx 一般为网页名称。
    4） POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。

    ps：保持一致比准确更重要

## 声明变量
在写程序的过程中我们会声明很多变量（成员变量，临时变量），而我们要知道变量的声明与使用策略是会对代码的可读性造成影响的：

- 变量越多，越难跟踪它们的动向。
- 变量的作用域越大，就需要跟踪它们的动向越久。
- 变量改变的越频繁，就越难跟踪它的当前值。

相对的，对于变量的声明与使用，我们可以从这三个角度来提高代码的可读性：

- 减少变量的个数
- 缩小变量的作用域
- 缩短变量声明与使用其代码的距离
#### 减少变量的个数

在一个函数里面可能会声明很多变量，但是有些变量的声明是毫无意义的，比如：

- 没有价值的临时变量
- 表示中间结果的变量
##### 没有价值的临时变量

有些变量的声明完全是多此一举，它们的存在反而加大了阅读代码的成本：
```
let now = datetime.now()
root_message.last_view_time = now
```
上面这个`now`变量的存在是毫无意义的，因为：

没有拆分任何复杂的表达式
`datetime.now()`已经很清楚地表达了意思,而且只使用了一次，因此而没有压缩任何冗余的代码
所以完全不用这个变量也是完全可以的：

```
root_message.last_view_time = datetime.now()
```
##### 表示中间结果的变量
有的时候为了达成一个目标，把一件事情分成了两件事情来做，这两件事情中间需要一个变量来传递结果。但往往这件事情不需要分成两件事情来做，这个“中间结果”也就不需要了：

看一个比较常见的需求，从数组中删除某个值：
```
var remove_value = function (array, value_to_remove){
    var index_to_remove = null;
    for (var i = 0; i < array.length; i+=1){
        if (array[i] === value_to_remove){
            index_to_remove = i;
            break;
        }
    }
    if (index_to_remove !== null){
        array.splice(index_to_remove,1);
    }
}
```
这里面把这个事情分成了两件事情来做：

找出要删除的元素的序号，保存在变量`index_to_remove`里面。
拿到`index_to_remove`以后使用`splice`方法删除它。（这段代码是JavaScript代码）
这个例子对于变量的命名还是比较合格的，但实际上这里所使用的中间结果变量是完全不需要的，整个过程也不需要分两个步骤进行。来看一下如何一步实现这个需求：

```
var remove_value = function (array, value_to_remove){
    for (var i = 0; i < array.length; i++){
        if (array[i] === value_to_remove){
            array.splice(i,1);
            return;
        }
    }
}
```
上面的方法里面，当知道应该删除的元素的序号i的时候，就直接用它来删除了应该删除的元素并立即返回。

除了减轻了内存和处理器的负担（因为不需要开辟新的内容来存储结果变量以及可能不用完全走遍整个的for语句），阅读代码的人也会很快领会代码的意图。

所以在写代码的时候，如果可以“速战速决”，就尽量使用最快，最简洁的方式来实现目的。
#### 缩小变量的作用域
变量的作用域越广，就越难追踪它，值也越难控制，所以我们应该让你的变量对尽量少的代码可见。

比如类的成员变量就相当于一个“小型局部变量”。如果这个类比较庞大，我们就会很难追踪它，因为所有方法都可以“隐式”调用它。所以相反地，如果我们可以把它“降格”为局部变量，就会很容易追踪它的行踪：
```
//成员变量，比较难追踪
class LargeCass{
  string str;

  void Method1(){
     str = ...;
     Method2();
  }

  void Method2(){
     //using str
  }
}
```
降格：
```
//局部变量，容易追踪
class LargeCass{

  void Method1(){
     string str = ...;
     Method2(str);
  }

  void Method2(string str){
     //using str
  }
}
```
所以在设计类的时候如果这个数据（变量）可以通过方法参数来传递，就不要以成员变量来保存它。
#### 缩短变量声明与使用其代码的距离
在实现一个函数的时候，我们可能会声明比较多的变量，但这些变量的使用位置却不都是在函数开头。

有一个比较不好的习惯就是无论变量在当前函数的哪个位置使用，都在一开始（函数的开头）就声明了它们。这样可能导致的问题是：阅读代码的人读到函数后半部分的时候就忘记了这个变量的类型和初始值；而且因为在函数的开头就声明了好几个变量，也对阅读代码的人的大脑造成了负担，因为人的短期记忆是有限的，特别是记一些暂时还不知道怎么用的东西。

因此，如果在函数内部需要在不同地方使用几个不同的变量，建议在真正使用它们之前再声明它。

## 如何写清楚的表达式

有些表达式比较长，很难让人马上理解。这时候最好可以将其拆分成更容易的几个小块。可以尝试下面的几个方法：

- 使用解释变量
- 使用总结变量
- 使用德摩根定理

#### 使用解释变量

有些变量会从一个比较长的算式得出，这个表达式可能很难让人看懂。这时候就需要用一个简短的“解释”变量来诠释算式的含义。使用书中的一个例子：

```
if (line.split(':')[0].strip() == "root")
```
其实上面左侧的表达式其实得出的是用户名，我们可以用username来替换它：
```
username = line.split(':')[0].strip()
if (username == "root")
```
#### 使用总结变量

除了以“变量”替换“算式”，还可以用“变量”来替换含有更多变量更复杂的内容，比如条件语句，这时候该变量可以被称为"总结变量"。使用书中的一个例子：

```
if(request.user.id == document.ownerId){
   //do something 
}
```
上面这条判断语句所判断的是：“该文档的所有者是不是该用户”。我们可以使用一个总结性的变量userOwnsDocument来替换它：
```
final boolean userOwnsDocument = (request.user.id == document.ownerId);
if (userOwnsDocument){
   //do something
}
```

#### 使用德摩根定理

德摩根定理:

- `not(a or b or c)`等价于`(not a) and (not b) and (not c)`
- `not(a and b and c)`等价于`(not a) or (not b) or (not c)`

当我们条件语句里面存在外部取反的情况，就可以使用德摩根定理来做个转换。使用书中的一个例子：

```
//使用德摩根定理转换以前
if(!(fileExists && !isProtected)){}

//使用德摩根定理转换以后
if(!fileExists || isProtected){}
```
## 如何写注释
首先引用书中的一句话：

`注释的目的是尽量帮助读者了解得和作者一样多。`

在你写代码的时候，在脑海中可能会留下一些代码里面很难体现出来的部分：这些部分在别人读你的代码的时候可能很难体会到。而这些“不对称”的信息就是需要通过以注释的方式来告诉阅读代码的人。

想要写出好的注释，就需要首先知道：

- 什么不能作为注释
- 什么应该作为注释

#### 什么不能作为注释
我们都知道注释占用了代码的空间，而且实际上对程序本身的运行毫无帮助，所以最好保证它是物有所值的。

不幸的是，有一些注释是毫无价值的，它无情的占用了代码间的空间，影响了阅读代码的人的阅读效率，也浪费了写注释的人的时间。这样的注释有以下两种：

- 描述能立刻从代码自身就能立刻理解的代码意图的注释
- 给不好的命名添加的注释
##### 描述能立刻从代码自身就能立刻理解的代码意图的注释
```
//将params1 和 params2 相加并返回他们的和
int sum =  params1 + params2;
return sum;
```
上面这个例子举的比较简单，但反映的问题很明显：这里面的注释是完全不需要的，它的存在反而增加了阅读代码的人的工作量。
##### 给不好的命名添加的注释
```
//get UserInfo from internet
- get()
```
该函数返回的是从网络获取用户信息。但这里只写了一个get，无法看出信息的来源。为了补充信息，使用注释来弥补。但其实这完全不必要。只要取一个适当的名字就好了：
```
- fetchUserInfo()
```
#### 什么应该作为注释

本书中介绍的注释大概有以下几种：

- 写代码时的思考
- 对代码的评价
- 常量

##### 写代码时的思考

你的代码可能不是一蹴而就的，它的产生可能会需要一些思考的过程。然而很多时候代码本身却无法将这些思考表达出来，所以你就可能有必要通过注释的方式来呈现你的思考，让阅读代码的人知道这段代码是哪些思考的结晶，从而也让读者理解了这段`代码为什么这么写`。如果遇到了比你高明的高手，在他看到你的注释之后兴许会马上设计出一套更加合适的方案。

##### 对代码的评价

有些时候你知道你现在写的代码是个临时的方案：它可能确实是解决当前问题的一个方法，但是：

- 你知道同时它也存在着某些缺陷，甚至是陷阱
- 你不知道有其他的方案可以替代了
- 你知道有哪个方案可以替代但是由于时间的关系或者自身的能力无法实现
- 也可能你知道你现在实现的这个方案几乎就是”完美的“，因为如果使用了其他的方案，可能会消耗更多的资源等等。
对于上面这些情况，你都有必要写上几个字作为注释来诚实的告诉阅读你的这段代码的人这段代码的情况，比如：
```
//该方案有一个很容易忽略的陷阱：****
//该方案是存在性能瓶颈，性能瓶颈在其中的**函数中
//该方案的性能可能并不是最好的，因为如果使用某某算法的话可能会好很多
```
##### 常量
在定义常量的时候，在其后面最好添加一个关于它是什么或者为什么它是这个值的原因。因为常量通常是不应该被修改的，所以最好把这个常量为什么是这个值说明一下：

例如：
```
IMAGE_QUALITY = 0.72 // 最佳的size/quanlity比率
RETRY_LIMIT   = 4    // 服务器性能所允许的请求失败的重试上限
```
##### 阿里巴巴注释规约
- 【强制】类、类属性、类方法的注释必须使用 Javadoc 规范，使用`/**内容*/`格式，不得使用`// xxx` 方式。
说明：在 IDE 编辑窗口中，Javadoc 方式会提示相关注释，生成 Javadoc 可以正确输出相应注
释；在 IDE 中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高
阅读效率。
- 【强制】所有的抽象方法（包括接口中的方法）必须要用 Javadoc 注释、除了返回值、参数、
异常说明外，还必须指出该方法做什么事情，实现什么功能。
说明：对子类的实现要求，或者调用注意事项，请一并说明。
- 【强制】所有的类都必须添加创建者和创建日期。
- 【强制】方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释
使用/* */注释，注意与代码对齐。
- 【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。
- 【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持
英文原文即可。
反例：“TCP 连接超时”解释成“传输控制协议连接超时”，理解反而费脑筋。
- 【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑
等的修改。
说明：代码与注释更新不同步，就像路网与导航软件更新不同步一样，如果导航软件严重滞后，
就失去了导航的意义。
- 【参考】谨慎注释掉代码。在上方详细说明，而不是简单地注释掉。如果无用，则删除。
说明：代码被注释掉有两种可能性：1）后续会恢复此段代码逻辑。2）永久不用。前者如果没
有备注信息，难以知晓注释动机。后者建议直接删掉（代码仓库保存了历史代码）。
- 【参考】对于注释的要求：第一、能够准确反应设计思想和代码逻辑；第二、能够描述业务含
义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同
天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路；注释也是给继任者看
的，使其能够快速接替自己的工作。
- 【参考】好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的
一个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担。
反例：
// put elephant into fridge 
put(elephant, fridge); 

方法名 put，加上两个有意义的变量名 elephant 和 fridge，已经说明了这是在干什么，语
义清晰的代码不需要额外的注释。
- 【参考】特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，
经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。
1） 待办事宜（TODO）:（ 标记人，标记时间，[预计处理时间]）
表示需要实现，但目前还未实现的功能。这实际上是一个 Javadoc 的标签，目前的 Javadoc
还没有实现，但已经被广泛使用。只能应用于类，接口和方法（因为它是一个 Javadoc 标签）。 2） 错误，不能工作（FIXME）:（标记人，标记时间，[预计处理时间]）
在注释中用 FIXME 标记某代码是错误的，而且不能工作，需要及时纠正的情况。

####  注释应当有很高的信息/空间率
注释应该用最简短的话来最明确地表达。要做到这一点需要做的努力是：
- 让注释保持紧凑：尽量用最简洁的话来表达，不应该有重复的内容
- 准确地描述函数的行为：要把函数的具体行为准确表达出来，不能停留在表明
- 用输入/输出的例子来说明特别的情况：有时相对于文字，可能用一个实际的参数和返回值就能立- -   刻体现出函数的作用。而且有些特殊情况也可以通过这个方式来提醒阅读代码的人
- 声明代码的意图：也就是说明这段代码存在的意义，你为什么当时是这么写的原因
其实好的代码是自解释的，由于其命名的合理以及架构的清晰，几乎不需要注释来向阅读代码的人添加额外的信息，书中有一个公式可以很形象地表明一个好的代码本身的重要性：

```
好代码 > (坏代码 + 注释)
```


# 控制流和逻辑的改进

控制流在编码中占据着很重要的位置，它往往代表着一些核心逻辑和算法。因此，如果我们可以让控制流变得看上去更加“自然”，那么就会对阅读代码的人理解这些逻辑甚至是整个系统提供很大的帮助。

那么都有哪相关实践呢？

- 使用符合人类自然语言的表达习惯
- if/else语句块的顺序
- 使用return提前返回
## 使用符合人类自然语言的表达习惯
写代码也是一个表达的过程，虽然表现形式不同，但是如果我们能够采用符合人类自然语言习惯的表达习惯来写代码，对阅读代码的人理解我们的代码是很有帮助的。

这里有两个比较典型的情景：
- 条件语句中参数的顺序
- 条件语句中的正负逻辑

####  条件语句中参数的顺序
首先比较一下下面两段代码，哪一个更容易读懂？
```
//code 1
if(length > 10)

//code 2
if(10 < length)
```
大家习惯上应该会觉得code1容易读懂。

再来看下面一个例子：
```
//code 3
if(receivedNumber < standardNumber) 

//code 4
if(standardNumber < receivedNumber)
```
仔细看会发现，和上面那一组情况类似，大多数人还是会觉得code3更容易读懂。

那么code1 和 code3有什么共性呢？
它们的共性就是：**左侧都是被询问的内容（通常是一个变量）；右侧都是用来做比较的内容（通常是一个常量）**
这应该是符合自然语言的一个顺序。比如我们一般会说“今天的气温大于20摄氏度”，而不习惯说“20摄氏度小于今天的气温”。

#### 条件语句中的正负逻辑
在判断一些正负逻辑的时候，建议使用if(result)而不是if(!result)。

因为大脑比较容易处理正逻辑，比如我们可能比较习惯说“某某某是个男人”，而不习惯说“某某某不是个女人”。如果我们使用了负逻辑，大脑还要对它进行取反，相当于多做了一次处理。

## if/else语句块的顺序
在写if/else语句的时候，可能会有很多不同的互斥情况（好多个elseif）。那么这些互斥的情况可以遵循哪些顺序呢？

- **先处理掉简单的情况，后处理复杂的情况**：这样有助于阅读代码的人循序渐进地地理解你的逻辑，而不是一开始就吃掉一个胖子，耗费不少精力。
- **先处理特殊或者可疑的情况，后处理正常的情况**：这样有助于阅读代码的人会马上看到当前逻辑的边界条件以及需要注意的地方。

## 使用return提前返回
在一个函数或是方法里，可能有一些情况是比较特殊或者极端的，对结果的产生影响很大（甚至是终止继续进行）。如果存在这些情况，我们应该把他们写在前面，用return来提前返回（或者返回需要返回的返回值）。

这样做的好处是可以减少if/else语句的嵌套，也可以明确体现出：“哪些情况是引起异常的”。
```java
public void function() {  
    if(IsWorkDay()) {  
       Sysetm.out.println("Error,is work day");  
    } else {  
       if(IsWorkTime()) { 
          Sysetm.out.println("Error ,is work time");  
       } else {  
          ... //执行内容
       }  
    }  
}
```
```java
public void function(){
    if(IsWorkDay()) {
        Sysetm.out.println("Error,is work day"); 
        return; 
    }
    if(IsWorkTime()) {
        Sysetm.out.println("Error ,is work time");
        return;
    }
    ...//执行内容
}
```

# 结构上的改进
关于代码组织的改进，作者介绍了以下三种方法:

- 抽取出与程序主要目的“不相关的子逻辑”
- 重新组织代码使它一次只做一件事情
- 借助自然语言描述来将想法变成代码
## 抽取出与程序主要目的“不相关的子逻辑”
一个函数里面往往包含了其主逻辑与子逻辑，我们应该积极地发现并抽取出与主逻辑不相关的子逻辑。具体思考的步骤是：

- 首先确认这段代码的高层次目标是什么（主要目标）？
- 对于每一行代码，都要反思一下：“它是直接为了目标而工作么？”
- 如果答案是否定的并且这些代码占据着一定数量的行数，我们就应该将他们抽取到独立的函数中。

比如某个函数的目标是为了**寻找距离某个商家最近的地铁口**，那么这其中一定会重复出现一些计算两组经纬度之间距离的子逻辑。但是这些子逻辑的具体实现是不应该出现在这个主函数里面的，因为这些细节与这个主函数的目标来讲应该是无关的。

即是说，像这种类似于工具方法的函数其实是脱离于某个具体的需求的：它可以用在其他的主函数中，也可以放在其他的项目里面。比如**找到离运动场场最近的几个公交站**这个需求等等。
## 重新组织代码使它一次只做一件事情
一个比较大的方法或者功能可能由很多任务代码组合而来，在这个时候我们有必要将他们分为更小的方法来调用它们。

这样做的好处是：我们可以清晰地看到这个功能是如何一步一步完成的，而且拆分出来的小的方法或许也可以用在其他的地方。

所以如果你遇到了比较难读懂的代码，可以尝试将它所做的所有任务列出来。可能马上你就会发现这其中有些任务可以转化成单独的方法或者类。而其他的部分可以简单的成为方法中的一个逻辑段落。

那怎么判断一件事的界限呢，基本方法是分层和解耦，每一层能一目了然就好，例如：
把大象装进冰箱里的程序。
主函数层是这样几步：

1. 把冰箱门打开；
2. 把大象装进去；
3. 把冰箱门关上。

其中引用了三个函数，拿函数 1.“把冰箱门打开”来看又细分为如下步骤：

1. 找到门把手；
2. 判断把手的触发类型；
3. 将门把手调整为开门状态；
4. 判断门是朝哪个方向开；
5. 打开门（返回）。

这些没有硬性的标准，是纯粹主观感知的，自己写完可以看一遍，通过篇幅、分段（块）等自己判断一下是否足够“一目了然”。

判断是否是“一件事”本身是无法精确实现的，全靠对函数的主观定义，比如如果我把函数定义成“打开冰箱门”，那这个函数就只能做打开冰箱门的事情，但如果定义为“开关冰箱门”就可以用来开或关冰箱门，这确实也可以理解为是“一件”事情。
换个角度来说，对于函数的规划是根据需求来不断变化的，所以做项目的时候要关心这个功能以后的发展方向是什么样的，然后根据对未来迭代对这个功能的修改进行适当的扩展性和维护性的设计，以后需求变成这样的话这个函数是否好改，改完后是否还能保持较好的扩展性和维护性。这需要经验。

## 借助自然语言描述来将想法变成代码
在设计一个解决方案之前，如果你能够用自然语言把问题说清楚会对整个设计非常有帮助。因为如果直接从大脑中的想法转化为代码，可能会露掉一些东西。

但是如果你可以将整个问题和想法滴水不漏地说出来，就可能会发现一些之前没有想到的问题。这样可以不断完善你的思路和设计。

# 复杂业务代码

简单的介绍下业务背景，零售通是给线下小店供货的B2B模式，我们希望通过数字化重构传统供应链渠道，提升供应链效率，为新零售助力。阿里在中间是一个平台角色，提供的是Bsbc中的service的功能。
![](https://pic1.zhimg.com/v2-d7fa5cae584924c7a5910a819a51853c_r.jpg)

在商品域，运营会操作一个“上架”动作，上架之后，商品就能在零售通上面对小店进行销售了。是零售通业务非常关键的业务操作之一，因此**涉及很多的数据校验和关联操作**。

针对上架，一个简化的业务流程如下所示：

![](https://pic3.zhimg.com/v2-97c659224f7958a806307c17be805b0e_r.jpg)

此处，我们可以使用结构化分解将问题解构成一个有层级的金字塔结构：
![](https://pic3.zhimg.com/v2-0a534a8f87d72f04a2fbc1a2ccec6e62_r.jpg)

按照这种分解写的代码，就像一本书，目录和内容清晰明了。

以商品上架为例，程序的入口是一个上架命令（OnSaleCommand）, 它由三个阶段（Phase）组成。
```
@Command
public class OnSaleNormalItemCmdExe {

    @Resource
    private OnSaleContextInitPhase onSaleContextInitPhase;
    @Resource
    private OnSaleDataCheckPhase onSaleDataCheckPhase;
    @Resource
    private OnSaleProcessPhase onSaleProcessPhase;

    @Override
    public Response execute(OnSaleNormalItemCmd cmd) {

        OnSaleContext onSaleContext = init(cmd);

        checkData(onSaleContext);

        process(onSaleContext);

        return Response.buildSuccess();
    }

    private OnSaleContext init(OnSaleNormalItemCmd cmd) {
        return onSaleContextInitPhase.init(cmd);
    }

    private void checkData(OnSaleContext onSaleContext) {
        onSaleDataCheckPhase.check(onSaleContext);
    }

    private void process(OnSaleContext onSaleContext) {
        onSaleProcessPhase.process(onSaleContext);
    }
}
```
每个Phase又可以拆解成多个步骤（Step），以OnSaleProcessPhase为例，它是由一系列Step组成的：
```
@Phase
public class OnSaleProcessPhase {

    @Resource
    private PublishOfferStep publishOfferStep;
    @Resource
    private BackOfferBindStep backOfferBindStep;
    //省略其它step

    public void process(OnSaleContext onSaleContext){
        SupplierItem supplierItem = onSaleContext.getSupplierItem();

        // 生成OfferGroupNo
        generateOfferGroupNo(supplierItem);

       // 发布商品
        publishOffer(supplierItem);

        // 前后端库存绑定 backoffer域
        bindBackOfferStock(supplierItem);

        // 同步库存路由 backoffer域
        syncStockRoute(supplierItem);

        // 设置虚拟商品拓展字段
        setVirtualProductExtension(supplierItem);

        // 发货保障打标 offer域
        markSendProtection(supplierItem);

        // 记录变更内容ChangeDetail
        recordChangeDetail(supplierItem);

        // 同步供货价到BackOffer
        syncSupplyPriceToBackOffer(supplierItem);

        // 如果是组合商品打标，写扩展信息
        setCombineProductExtension(supplierItem);

        // 去售罄标
        removeSellOutTag(offerId);

        // 发送领域事件
        fireDomainEvent(supplierItem);

        // 关闭关联的待办事项
        closeIssues(supplierItem);
    }
}
```
对于这种业务流程的表达，简单朴素的组合方法模式（Composed Method）是再合适不过的了。

因此，在做过程分解的时候，我建议工程师不要把太多精力放在工具上，放在设计模式带来的灵活性上。而是应该多花时间在对问题分析，结构化分解，最后通过合理的抽象，形成合适的阶段（Phase）和步骤（Step）上。
![](https://pic1.zhimg.com/v2-b2528b1ddcc7bdb83e4639069ec2f704_r.jpg)